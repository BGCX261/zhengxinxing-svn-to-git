= To Do List =
  * BUG: 下落触底时中，偶尔出现部分小方块被“吃掉”，或者一行本不满的整行被消掉。特别是在下落时候多按几下down
  * 落地方块变色
  * 方块清空动画
  * 方块满格后，游戏终止
  * 作者信息、积分等文字的显示
  * 预显示新的 Unit 于右上角
  * 游戏的初始界面，包括功能选择、按键设置等
  * 编制 unit test，重构代码
  * 美化界面
  * 撰写“pygame教程之俄罗斯方块”

= 2008.04.01 =
  * 完善 Unit 的样式，目前可以实现所有7种基本样式
  * 进一步修正 Unit 的旋转算法，针对不同样式采用不同策略
  * 重构部分代码，包括 random() 函数
  * 添加了 游戏暂停 功能（p 键）
  * 修正BUG: 连续多个满行清空时，仅下降一行
  * 修正BUG: 满行自动清空后，未能下移

= 2008.03.31 =
  * 完善了 Unit 的旋转算法
  * 解决了昨日的“下落触底框瞬间，unit 的部分方块还可以左右移动”的bug
  * BUG: 满行自动清空后，未能自动下移上面各行

= 2008.03.30 =
  * 实现了初步的 Unit 的顺时针旋转算法。
  * BUG: 在下落触底框瞬间，unit 的部分方块还可以左右移动

= 2008.03.29 =
  * 实现了 class Unit 的基本功能，包括左右移动、下移，以及遇见 bottoms 的处理。
  * BUG: 在下落触底判定的时候，偶尔会出现 unit 的最下面一排方块被“吃掉”

= 2008.03.28 =
  * 修正了 class Block 的 id 号算法 bug 。原先用静态类成员作为对象的 id 号返回，这样做是错误的
  * 修正了 class Block 的碰撞检测 bug，原先在横向放大碰撞，这样是不对的，只需要在纵向放大即可
  * 完成了 class Bottoms 的满行清空功能。现在 class Bottoms 的代码基本可以不用变了

= 2008.03.28 =
完成了 calculate_down_steps 函数，以及满行清空动作。发现方块们的清空非常简单，只要调用 Group.remove() 函数就好了。

= 2008.03.27 =
python里面的二维数组，不能使用 `lines = [[0] * col] * row` 的形式来实现，而应该用 `lines = [[0 for a in range(col)] for b in range(row)]` 。前者的语法有误在于，它所创建的是一堆的拷贝，而不是独立的列表。

问题

  * 一个类方法继承的问题。pygame.sprite.RenderUpdates 有 add() 函数，我从它继承出 Bottoms 类，重写 add() 的时候调用 pygame.sprite.RenderUpdates.add() 为什么会出现无限嵌套失误？后来将 Bottoms.add() 改名为 Bottoms.my_add() 就正常了。（这是可能是因为 pygame.sprite.AbstractGroup.add() 的实现里面，使用了 self.add(spr) 这样的语句，导致内部函数调用的混乱。解决办法：在 AbstractGroup.add() 函数里面，使用 AbstractGroup.add(self, spr) 代替 self.add(spr) 一句）
  * 在判定下落移动控制的时候，必须给出一个下落间隔的延迟，如何实现？另外新生成的方块，在首次移动前，也需要一个下落延迟
  * 文件使用 utf-8 编码的时候，pygame.display.set_caption() 函数无法正常显示中文。如果直接用 `'中文'` 会导致输出乱码，如果用 `u'中文'` 会出错。
  * 函数定义的时候，参数前面带 `*` 或者 `**` 是什么意思？（def func(*a) 表示该函数允许的参数不限个数，内部用tuple存储之； def func(**a) 也一样，只是内部用dict存储，所以调用时必须指定名称与值。）（参见python手册中的“Language Reference”的“Functions Definition”）



= 2008.03.26 =
今日实现了小方块的下落控制、新方块的生成。另外，还开始实现 Bottoms 的满行清空算法。为了这个算法，以及将来的计数，于是给 Block 类添加了一个类成员 number，也由此学会了 python 里面类成员的用法

目前遗留一个bug: 小方块之间的碰撞判定，新方块右边与旧方块左边

= 2008.03.25 =
  * 构思了游戏整体界面并画出来
  * 修改代码并实现了方块在游戏主界面内的移动控制
  * 下一步：考虑bottoms的实现

= 2008.03.23 =

  * 目前程序已实现单一方块的移动处理，并利用固定宽度，方便图片边界判定
  * 图片像素处理。原图片采用一个像素的白边框，现改为无边框，方便程序中图片边界的判定
  * 目前进入一个瓶颈，即不知如何实现游戏对象、游戏逻辑的分离，以及如何实现bottoms相关的sprite事务

= 2008.03.22 =

进度

  - 实现了初步的方块下落框架，目前以可以显示初步的图像。但此框架基本上还是处于实验阶段
  - 考虑到以像素的碰撞检测可能效率比较低，决定采用多个小方块来组成单元进行控制，但此构思目前还有待验证
  - 重构：将方块的像素宽度写入 common.py
  - 重构：用一个 _move() 函数集中了方块的移动处理

问题

  - 使用 key.get_pressed() 可以实现 block 移动的连续控制，但是输出太多太快，玩家可能觉得不好控制。而 event 列表模式则一次按键只能输出一次，玩家更不好控制。如何实现键盘按键的“长短键”检测与控制呢？
  - 如何实现多方块的单元的控制？如移动等

= 2008.03.21 =

  * 好久没使用svn的冲突解决相关功能了，今日上网查了一下手册，才知道，解决后要用 resolved 命令通知svn，然后svn就会将3个临时文件删除
  * aliens.py: 这是一个小射击游戏，有很多基础的python元素，有待学习（参考官方教程《Making games with Pygame》）
  * 学习官方教程《Sprite Module Introduction》

= 2008.03.20 =

学习pygame基础

  - 物体定时移动控制：利用time.set_timer(USEREVENT, 1000) 可以实现1秒一次的定时器
  - 物体移动三部曲：首先恢复背景 screen.blit(background, player_rect, player_rect)，然后移动目标 play.move_left() ，最后显示目标 screen.blit(player, player_rect)
  - 精确的碰撞检测：可以通过检测碰撞区域内是否存在非透明像素重叠来实现，但此法低效。据说也可以通过 ANDing sprite mask 来实现，但是据说效率都非常低下。
  - 键盘检测：利用 pygame.key.get_pressed() 可以获得当前被按下的键，此可以实现长按键的连续控制


= 2008.03.18 =

继续学习chimp.py

  - 两个图片重叠时，谁在上面，由加入 group 时候的先后顺序决定，先加入者在底部（RenderPlain((chimp, fist)) 这一句）
  - rect.move_ip(a,b): 将本图片偏移一点显示
  - rect.colliderect(rect)：检测本四方形是否与另一个四方形有所重叠。虽然图片外围有些被设置成透明的，但是 image.get_rect() 所返回的结果，是包括透明区域在内的四方形。
  - 一个对象往往需要两个参数：rect与image，当image变动时，需要随即根据image更新rect
  - transform.flip(image, x, y)：将图片上下、左右反转

问题

  - 当图片外围包含透明区域时，如何检测“两个图片非透明区域碰撞”呢？比如L形方块的碰撞检测
  - 如何实现各物体移动速度的控制？比如让方块以1秒一次的频率移动

= 2008.03.17 =

  - 查得“俄罗斯方块”的正规名称是“Tetris”，于是更改相关名称。
  - 学习pygame的简单案例“chimp.py”，更改该案例各处的参数，深入了解其含义
